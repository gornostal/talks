
<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Introduction to WebRTC</title>

        <meta name="description" content=">Introduction to WebRTC">
        <meta name="author" content="Aleksandr Gornostal">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/default.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="print">

        <!-- my styles -->
        <style>
            .reveal h1,
            .reveal h2 {
                text-shadow: 2px 4px 6px #ccc;
            }
            .reveal h1,
            .reveal h2,
            .reveal h3 {
                text-transform: none;
                line-height: 1em;
            }
            .simple-image {border: none !important; box-shadow: none !important; }
        </style>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

<section>
    <h1>Introduction to WebRTC</h1>
    <img src="img/logo.png" class="simple-image" alt="">
    <br /><br /><br />
    <p>
        <small>by <a href="http://github.com/gornostal">Aleksandr Gornostal</a></small>
    </p>
</section>

<section>
    <h2>Demo</h2>
    <h3><a href="http://webrtc-app.gornostal.name/">http://webrtc-app.gornostal.name/</a></h3>
    <br />
    <small>Source - <a href="https://github.com/gornostal/my-webrtc-app">https://github.com/gornostal/my-webrtc-app</a></small>
</section>

<section>
    <h2>P2P Connection</h2>

    <img src="img/p2p.png" alt="" />

    <aside class="notes">
        Ідея - зробити можливим передачу потокового відео/аудіо (чи інших даних) напряму між браузерами.<br />
        Щоб зменшити об’єми даних які проходять через сервери.<br />

        І все було б досить просто, аби не існувало такого поняття як NAT, а всі комп’ютери мали статичні ІР<br />
        Якщо комп’ютери за НАТом, то ситуація складніша.<br />
        Використовувати третій хост з виділеним ІР для трансляції трафіка - не варіант.
    </aside>
</section>

<section>
    <h2>Session Traversal Utilities for NAT (<a href="http://en.wikipedia.org/wiki/STUN">STUN</a>)</h2>

    <img src="img/stun.png" alt="" />

    <aside class="notes">
        Якщо коротко, то STUN сервер потрібен для визначення свого зовнішного ІР<br />
        Трафік через нього проходити не буде.<br />
        Існує велика кількість безкоштовних STUN серверів.<br />
        STUN не працює в мережах з симетричними NAT
    </aside>
</section>


<section>
    <h2>Traversal Using Relay NAT (<a href="http://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT">TURN</a>)</h2>

    <img src="img/turn.png" alt="" />

    <aside class="notes">
        Протокол дозволяє вузлу за НАТ отримувати вхідні дані.
    </aside>
</section>

<section>
    <h2>Interactive Connectivity Establishment (<a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">ICE</a>)</h2>
    <img src="img/ice.png" alt="Finding connection candidates" />
    <aside class="notes">
        Протокол для обходу НАТ
    </aside>
</section>

<section>
    <h2>WebRTC data pathways</h2>
    <img src="img/data_pathways.png" alt="WebRTC data pathways">
</section>

<section>
    <h2>WebRTC Components:</h2>
    <ul>
        <li>MediaStream (aka getUserMedia)</li>
        <li>RTCPeerConnection</li>
        <li>RTCDataChannel</li>
    </ul>
</section>

<section>
    <h2>MediaStream</h2>
    <h3>(aka getUserMedia)</h3>

    <pre><code data-trim>
window.URL = window.URL || window.webkitURL;
navigator.getUserMedia  = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

navigator.getUserMedia(
    {video: true, audio: true}, // constraints object

    function(localMediaStream){ // success callback
        var video = document.createElement("video");
        video.autoplay = true;
        video.src = window.URL.createObjectURL(localMediaStream);
        document.body.appendChild(video);
    },

    function(error){ // failure callback
        console.error(error);
    }
);
    </code></pre>
</section>

<section>
    <h2>RTCPeerConnection</h2>

    <ul>
        <li>packet loss concealment</li>
        <li>echo cancellation</li>
        <li>bandwidth adaptivity</li>
        <li>dynamic jitter buffering</li>
        <li>automatic gain control</li>
        <li>noise reduction and suppression</li>
        <li>image 'cleaning'</li>
    </ul>

    <aside class="notes">
        Компонент, який забезпечує стабільне та ефективне з’єднання між юзерами
    </aside>
</section>

<section>
    <h2>RTCDataChannel</h2>
    <p>API for high performance, low latency, peer-to-peer communication of arbitrary data</p>
</section>

<section>
    <h2>WebRTC Connection Process</h2>
    <a href="img/webrtc-connection-process.png">
        <img src="img/webrtc-connection-process.png" alt="WebRTC Connection Process" />
    </a>
</section>

<section>
    <h2>Caveats</h2>
    <ul>
        <li>Peers must be present with local streaming video before sending offer/answer SDP</li>
        <li>For 'Answerer'; Do not add ICE candidate until the peer generates the 'Answer SDP'</li>
        <li>Once remote media starts streaming stop adding ICE candidates</li>
        <li>Never create 'Answer SDP' until you get the 'Offer SDP'</li>
    </ul>
</section>

<section>
    <h2>Interoperability</h2>

    <p><q>
        <a href="https://nightly.mozilla.org/">Firefox Nightly</a> (as of 1/30/13) and
        <a href="https://www.google.com/intl/en/chrome/browser/beta.html">Chrome M25 Beta</a>
        and later are interoperable, but currently require a "small" degree of adaptation on the part of the calling site.
    </q></p>
    <br />
    <p>
        <small>
            More here: <a href="https://sites.google.com/site/webrtc/interop">https://sites.google.com/site/webrtc/interop</a>
        </small>
    </p>
</section>

<section>
    <h2>Learn more</h2>
    <ul>
        <li><a href="https://apprtc.appspot.com/">apprtc.appspot.com</a></li>
        <li><a href="https://bistri.com/">bistri.com</a></li>
        <li>Blog <a href="https://webrtc-experiment.appspot.com/">WebRTC Experiments & Demos</a> by Muaz Khan</li>
        <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">html5rocks.com/en/tutorials/webrtc/basics/</a></li>
        <li><a href="https://www.youtube.com/watch?v=E8C8ouiXHHk">Video of Justin Uberti's WebRTC session at Google I/O, 27 June 2012</a></li>
    </ul>
</section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.min.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                rollingLinks: false,

                theme: Reveal.getQueryHash().theme || 'beige', // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
